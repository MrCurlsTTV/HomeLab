- name: Create HAProxy certs directory
  file:
    path: /etc/haproxy/certs
    state: directory
    owner: root
    group: root
    mode: '0700'

- name: Create Let's Encrypt configuration directory
  file:
    path: /etc/letsencrypt/conf
    state: directory
    owner: root
    group: root
    mode: '0700'

- name: Copy Cloudflare configuration file
  template:
    src: templates/cloudflare.ini.j2
    dest: /etc/letsencrypt/cloudflare.ini
    owner: root
    group: root
    mode: '0600'

- name: Copy DNS-01 challenge hook script
  copy:
    src: files/letsencrypt-dns-01-hook.sh
    dest: /usr/local/bin/letsencrypt-dns-01-hook.sh
    owner: root
    group: root
    mode: '0700'

- name: Copy DNS cleanup hook script
  copy:
    src: files/letsencrypt-dns-cleanup-hook.sh
    dest: /usr/local/bin/letsencrypt-dns-cleanup-hook.sh
    owner: root
    group: root
    mode: '0700'

- name: Copy certificate renewal script
  copy:
    src: files/renew-certs.sh
    dest: /usr/local/bin/renew-certs.sh
    owner: root
    group: root
    mode: '0700'

- name: Install jq for JSON processing
  package:
    name: jq
    state: present

- name: Install certbot and dependencies
  apt:
    name:
      - certbot
      - python3-setuptools
      - python3-dev
      - git
      - build-essential
    state: present
    update_cache: yes

- name: Clone certbot-dns-cloudflare repository
  git:
    repo: https://github.com/certbot/certbot.git
    dest: /tmp/certbot
    version: master
    depth: 1

- name: Install certbot-dns-cloudflare from source
  shell: |
    cd /tmp/certbot/certbot-dns-cloudflare
    python3 setup.py install
  args:
    creates: /usr/local/lib/python3*/dist-packages/certbot_dns_cloudflare*.egg-info

- name: Create certbot directories
  file:
    path: "{{ item }}"
    state: directory
    owner: root
    group: root
    mode: '0755'
  with_items:
    - /etc/letsencrypt
    - /var/lib/letsencrypt
    - /var/log/letsencrypt
    - /etc/letsencrypt/renewal-hooks/post

- name: Copy certificate renewal hooks
  copy:
    src: "files/{{ item }}"
    dest: "/etc/letsencrypt/renewal-hooks/post/{{ item | basename }}"
    owner: root
    group: root
    mode: '0755'
  with_items:
    - renew-certs.sh

- name: Create symlink for post-hook script (fixes certbot post-hook error)
  file:
    src: /usr/local/bin/renew-certs.sh
    dest: /etc/letsencrypt/renewal-hooks/post/renew-certs.sh
    state: link
    force: yes
  become: true

- name: Add certificate renewal cron job
  cron:
    name: "Renew Let's Encrypt certificates"
    special_time: daily
    job: "certbot renew --quiet"
    user: root


# Copy over the certificate request script
- name: Copy certificate request script
  copy:
    src: files/request-cert.sh
    dest: /usr/local/bin/request-cert.sh
    owner: root
    group: root
    mode: '0755'
  become: true

# Copy over the certificate cleanup script
- name: Copy certificate cleanup script
  copy:
    src: files/cleanup-certs.sh
    dest: /usr/local/bin/cleanup-certs.sh
    owner: root
    group: root
    mode: '0755'
  become: true

# Copy diagnostic script
- name: Copy HAProxy certificate diagnostic script
  copy:
    src: files/haproxy-cert-diagnostic.sh
    dest: /usr/local/bin/haproxy-cert-diagnostic.sh
    owner: root
    group: root
    mode: '0755'
  become: true

# Fix line endings on all shell scripts (convert CRLF to LF)
- name: Fix line endings on certificate management scripts
  shell: sed -i 's/\r$//' "{{ item }}"
  become: true
  with_items:
    - /usr/local/bin/request-cert.sh
    - /usr/local/bin/cleanup-certs.sh
    - /usr/local/bin/renew-certs.sh
    - /usr/local/bin/haproxy-cert-diagnostic.sh
    - /usr/local/bin/letsencrypt-dns-01-hook.sh
    - /usr/local/bin/letsencrypt-dns-cleanup-hook.sh

- name: Verify scripts are executable after line ending fix
  stat:
    path: "{{ item }}"
  with_items:
    - /usr/local/bin/request-cert.sh
    - /usr/local/bin/cleanup-certs.sh
    - /usr/local/bin/renew-certs.sh
    - /usr/local/bin/haproxy-cert-diagnostic.sh
  register: script_verification

- name: Display script verification results
  debug:
    msg: "{{ item.item | basename }}: {{ 'OK' if item.stat.exists and item.stat.executable else 'FAILED' }}"
  with_items: "{{ script_verification.results }}"


# Clean up any existing duplicate certificates first
- name: Clean up any duplicate certificates
  command: /usr/local/bin/cleanup-certs.sh
  become: true
  ignore_errors: true

# Check if Let's Encrypt certificate already exists
- name: Check if certificate already exists
  stat:
    path: "/etc/letsencrypt/live/{{ domain_name }}/cert.pem"
  register: cert_file

# Add random delay to prevent simultaneous certificate requests
- name: Add random delay to prevent simultaneous requests
  wait_for:
    timeout: "{{ ansible_play_hosts.index(inventory_hostname) * 30 }}"
  when: not cert_file.stat.exists | default(true)

- name: Issue Let's Encrypt certificate with the certificate request script
  command: >
    /usr/local/bin/request-cert.sh
    -d {{ domain_name }}
    {% for domain in additional_domains %}
    -d {{ domain }}
    {% endfor %}
    -e {{ letsencrypt_email }}
    -p {{ dns_propagation_seconds | default(120) }}
    -c /etc/letsencrypt/cloudflare.ini
    -r 3
    -s haproxy
  become: true
  when: not cert_file.stat.exists | default(true)
  ignore_errors: true

- name: Log certificate request status
  debug:
    msg: "{{ inventory_hostname }} {{ 'requested' if not cert_file.stat.exists else 'already has' }} Let's Encrypt certificate"

# After the certificate issuance task, check for any certificates (all nodes)
- name: Check for any Let's Encrypt certificates (including with suffixes)
  find:
    paths: /etc/letsencrypt/live
    patterns: "{{ domain_name }}*"
    file_type: directory
  register: letsencrypt_cert_dirs
  ignore_errors: true

# Create directory for HAProxy certificates (all nodes)
- name: Create HAProxy certs directory
  file:
    path: /etc/haproxy/certs
    state: directory
    owner: root
    group: root
    mode: '0700'

# Combine certificates for HAProxy if any are found (all nodes)
- name: Combine certificates for HAProxy
  shell: |
    for domain_dir in $(find /etc/letsencrypt/live/ -maxdepth 1 -type d | grep -v README); do
      domain_name=$(basename "$domain_dir" | sed 's/-[0-9]*$//')  # Remove suffixes like -0001
      if [ -f "$domain_dir/fullchain.pem" ] && [ -f "$domain_dir/privkey.pem" ]; then
        cat "$domain_dir/fullchain.pem" "$domain_dir/privkey.pem" > "/etc/haproxy/certs/$domain_name.pem"
        chmod 600 "/etc/haproxy/certs/$domain_name.pem"
        echo "Created combined certificate for $domain_name"
      fi
    done
  when: letsencrypt_cert_dirs.matched > 0 or cert_file.stat.exists | default(false)


- name: Check if HAProxy certificate is now available
  stat:
    path: "/etc/haproxy/certs/{{ domain_name }}.pem"
  register: haproxy_cert_final_check

- name: Update HAProxy configuration with SSL
  template:
    src: templates/haproxy_ssl.cfg.j2
    dest: /etc/haproxy/haproxy.cfg
    owner: root
    group: root
    mode: '0644'
  when: haproxy_cert_final_check.stat.exists
  notify: Restart HAProxy

- name: Log SSL configuration update
  debug:
    msg: "{{ inventory_hostname }}: HAProxy SSL configuration {{ 'updated' if haproxy_cert_final_check.stat.exists else 'skipped (no certificate)' }}"

- name: Ensure HAProxy is restarted after SSL configuration
  systemd:
    name: haproxy
    state: restarted
  when: haproxy_cert_final_check.stat.exists

- name: Verify HAProxy is running with SSL
  systemd:
    name: haproxy
    state: started
  when: haproxy_cert_final_check.stat.exists